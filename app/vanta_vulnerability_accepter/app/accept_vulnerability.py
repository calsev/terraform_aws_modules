import json
import logging
import os
import time
import typing
import urllib.parse
import urllib.request

import boto3

logger = logging.getLogger("vuln-accepter")
logger.setLevel(logging.INFO)

SECRET_ID = os.environ.get(
    "SECRET_ID",
    "${secret_id}",
)
SEVERITY_LEVEL_LIST_TO_ACCEPT = os.environ.get(
    "SEVERITY_LEVEL_LIST_TO_ACCEPT",
    "${severity_level_list_to_accept}",
)


def get_secret_json(
    secret_id: str,
) -> dict[str, str]:
    logger.info(f"Fetching secret {secret_id}")
    client = typing.cast(typing.Any, boto3.client("secretsmanager"))
    secret_str = client.get_secret_value(SecretId=secret_id)["SecretString"]
    return json.loads(secret_str)


def http_post_json(
    url: str,
    headers: dict[str, str],
    body: dict[str, typing.Any],
) -> dict[str, typing.Any]:
    data = json.dumps(body).encode("utf-8")
    req = urllib.request.Request(
        url,
        data=data,
        headers=headers,
        method="POST",
    )
    with urllib.request.urlopen(req) as resp:
        if resp.status >= 400:
            raise RuntimeError(f"HTTP {resp.status} {resp.reason}")
        return json.loads(resp.read().decode())


def http_get_json(
    url: str,
    headers: dict[str, str],
    params: dict[str, str] | None = None,
) -> dict[str, typing.Any]:
    if params:
        query = urllib.parse.urlencode(params)
        url = f"{url}?{query}"
    req = urllib.request.Request(
        url,
        headers=headers,
        method="GET",
    )
    with urllib.request.urlopen(req) as resp:
        if resp.status >= 400:
            raise RuntimeError(f"HTTP {resp.status} {resp.reason}")
        return json.loads(resp.read().decode())


def get_access_token(secret_data: dict[str, str]) -> str:
    logger.info("Fetching token")
    data = http_post_json(
        "https://api.vanta.com/oauth/token",
        headers={
            "Content-Type": "application/json",
        },
        body={
            "client_id": secret_data["oath_client_id"],
            "client_secret": secret_data["oath_client_secret"],
            "scope": "vanta-api.all:read vanta-api.all:write",
            "grant_type": "client_credentials",
        },
    )
    access_token = data["access_token"]
    return access_token


def sleep_for_throttle() -> None:
    # Rate limit is 50/minute
    time.sleep(1.2)


def accept_vulnerability_page(
    access_token: str,
    vulnerability_list: list[dict[str, typing.Any]],
) -> None:
    for i_vuln, vulnerability in enumerate(vulnerability_list):
        vulnerability_id = vulnerability["id"]
        logger.info(f"  {i_vuln + 1} / {len(vulnerability_list)} {vulnerability_id}")
        http_post_json(
            "https://api.vanta.com/v1/vulnerabilities/deactivate",
            body={
                "updates": [
                    {
                        "deactivateReason": "Risk accepted",
                        "id": vulnerability_id,
                        "shouldReactivateWhenFixable": False,
                    }
                ]
            },
            headers={
                "accept": "application/json",
                "content-type": "application/json",
                "authorization": f"Bearer {access_token}",
            },
        )
        sleep_for_throttle()


def accept_vulnerabilities_for_severity_level(
    access_token: str,
    severity_level: str,
) -> None:
    logger.info(f"Accepting {severity_level} vulnerabilities")
    i_page = 1
    has_next_page = True
    end_cursor = None
    while has_next_page:
        logger.info(f"Page {i_page}")
        params = {
            "isDeactivated": "false",
            "pageSize": "100",
            "severity": severity_level,
        }
        if end_cursor:
            params["pageCursor"] = end_cursor
        data = http_get_json(
            "https://api.vanta.com/v1/vulnerabilities",
            headers={
                "accept": "application/json",
                "Authorization": f"Bearer {access_token}",
            },
            params=params,
        )
        sleep_for_throttle()
        results = data["results"]
        page_info = results["pageInfo"]
        has_next_page = page_info["hasNextPage"]
        end_cursor = page_info["endCursor"]
        vulnerability_list = results["data"]
        accept_vulnerability_page(
            access_token=access_token,
            vulnerability_list=vulnerability_list,
        )
        i_page += 1


def accept_vulnerabilities():
    logger.info(f"Severity list is {SEVERITY_LEVEL_LIST_TO_ACCEPT}")
    severity_level_to_accept_list = SEVERITY_LEVEL_LIST_TO_ACCEPT.split(",")
    secret_data = get_secret_json(SECRET_ID)
    access_token = get_access_token(secret_data)

    for severity_level in severity_level_to_accept_list:
        accept_vulnerabilities_for_severity_level(
            access_token=access_token,
            severity_level=severity_level,
        )


def lambda_handler(
    event: dict[str, typing.Any],
    context: dict[str, typing.Any],
) -> dict[str, typing.Any]:
    logger.info("Lambda handler started")
    accept_vulnerabilities()
    return {
        "statusCode": 200,
        "body": json.dumps({"success": True}),
    }


if __name__ == "__main__":
    accept_vulnerabilities()
