resource "aws_autoscaling_group" "this_asg" {
  for_each                         = local.lx_map
  availability_zones               = null # Conflicts with vpc_zone_identifier
  capacity_rebalance               = true
  default_cooldown                 = 300
  default_instance_warmup          = 0
  desired_capacity                 = each.value.auto_scaling_num_instances_min
  desired_capacity_type            = null # Default "units" causes a dirty plan
  enabled_metrics                  = null # All by default
  force_delete                     = false
  force_delete_warm_pool           = false
  health_check_grace_period        = 300
  health_check_type                = each.value.health_check_type
  ignore_failed_scaling_activities = false
  # initial_lifecycle_hook # TODO
  instance_maintenance_policy {
    max_healthy_percentage = each.value.instance_maintenance_max_healthy_percentage
    min_healthy_percentage = each.value.instance_maintenance_min_healthy_percentage
  }
  instance_refresh {
    preferences {
      # alarm_specification
      auto_rollback                = false
      checkpoint_delay             = 3600
      checkpoint_percentages       = null
      instance_warmup              = null
      max_healthy_percentage       = each.value.instance_refresh_max_healthy_percentage
      min_healthy_percentage       = each.value.instance_refresh_min_healthy_percentage
      scale_in_protected_instances = each.value.instance_refresh_protected_instance_enabled ? "Refresh" : "Ignore"
      skip_matching                = false
      standby_instances            = each.value.instance_refresh_protected_instance_enabled ? "Terminate" : "Ignore"
    }
    strategy = "Rolling"
    triggers = ["max_instance_lifetime"]
  }
  launch_configuration = null # Conflicts with launch_template
  launch_template {
    id      = each.value.launch_template_id
    version = "$Default"
  }
  lifecycle {
    ignore_changes = [
      desired_capacity,
      tag, # This is where ECS adds tags for managed ASG
    ]
  }
  load_balancers        = null # Obsolete: classic load balancer
  max_instance_lifetime = each.value.instance_lifetime_max_hours * 60 * 60
  metrics_granularity   = "1Minute"
  min_elb_capacity      = null # TF Wait
  # mixed_instances_policy # Conflicts with launch_template
  name        = null                            # Conflicts with name_prefix
  name_prefix = each.value.resource_name_prefix # Name causes issues with replacing
  max_size                = each.value.auto_scaling_num_instances_max
  min_size                = each.value.auto_scaling_num_instances_min
  placement_group         = each.value.placement_group_id
  protect_from_scale_in   = each.value.auto_scaling_protect_from_scale_in
  service_linked_role_arn = each.value.auto_scaling_iam_role_arn_service_linked
  suspended_processes     = each.value.suspended_processes
  dynamic "tag" {
    for_each = each.value.tags
    content {
      key                 = tag.key
      value               = tag.value
      propagate_at_launch = true
    }
  }
  termination_policies = [
    "OldestLaunchConfiguration",
    "OldestLaunchTemplate",
    "OldestInstance",
    "AllocationStrategy",
    "Default",
  ]
  target_group_arns    = each.value.elb_target_group_arn_list
  # traffic_source # TODO
  vpc_zone_identifier       = each.value.vpc_subnet_id_list
  wait_for_capacity_timeout = "10m"
  wait_for_elb_capacity     = null # TF Wait
  # warm_pool # TODO
}

{{ alarm.main(prepend="asg") }}
